<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proffie Style Parser</title>
	<link rel="stylesheet" href="./assets/css/style.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #e0e0e0;
        }

        textarea {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: all 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
        }

        .parse-btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
        }

        .parse-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .export-btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
		
		.buttons-group {
			display: flex;
			flex-wrap: wrap;
			gap: 3px;
			margin-left: 10px;
			align-items: center;
		}

        .tree-view {
            margin-top: 30px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
			overflow-x: auto;
        }

        .node {
            margin: 5px 0;
        }

        .node-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 3px solid #00d4ff;
			min-width: 0;
			flex-wrap: wrap;
        }

        .node-header:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .expand-icon {
            margin-right: 10px;
            font-family: monospace;
            font-size: 12px;
            width: 15px;
            color: #00d4ff;
        }

        .function-name {
            font-weight: 600;
            color: #ff6b6b;
			flex-shrink: 0;
			white-space: nowrap;
            margin-right: 10px;
        }

        .parameters {
            color: #4ecdc4;
            font-size: 0.9rem;
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
			flex: 1 1 auto;
			min-width: 0;
        }

		.parameter-input {
			background: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 5px;
			padding: 4px 8px;
			color: #ffffff;
			font-size: 0.9rem;
			margin: 0 4px;
			flex: 1 1 40px;
			min-width: 0;
			max-width: 100%;
			width: auto;
		}

        .parameter-input:focus {
            outline: none;
            border-color: #00d4ff;
        }
		
		.param-buttons-wrap {
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
			align-items: center;
			flex: 1 1 auto;
		}
		
		.param-container {
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			flex: 1;
			min-width: 0;
		}

		.param-top-line {
			display: flex;
			flex-direction: row;
			align-items: center;
			flex-wrap: wrap;
			gap: 10px;
		}

		.param-wrap {
			flex: 1;
			min-width: 0;
			display: flex;
			flex-wrap: wrap;
			gap: 6px;
		}

        .action-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 3px;
            color: #ffffff;
            font-size: 0.8rem;
            padding: 0;
            margin: 0 1px;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.6;
            width: 22px;
            height: 22px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            opacity: 1;
            transform: scale(1.05);
        }

        .expand-btn.modified {
            opacity: 1;
            background: rgba(0, 212, 255, 0.3);
        }

        .expand-btn.modified:hover {
            background: rgba(0, 212, 255, 0.5);
        }
		
		.parameter-group {
			display: flex;
			align-items: center;
			margin: 0 2px;
			flex: 1 1 40px;
			min-width: 0;
		}

        .node-children {
            margin-left: 30px;
            margin-top: 10px;
            border-left: 2px solid rgba(0, 212, 255, 0.3);
            padding-left: 15px;
        }

        .hidden {
            display: none;
        }

        .error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            color: #ff6b6b;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 15% auto;
            padding: 30px;
            border-radius: 15px;
            width: 500px;
            max-width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .modal h3 {
            color: #00d4ff;
            margin-bottom: 20px;
        }

        .modal label {
            display: block;
            margin-bottom: 8px;
            color: #e0e0e0;
            font-weight: 600;
        }

        .modal input[type="text"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 14px;
        }

        .modal input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-btn.primary {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .modal-btn.secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .modal-btn:hover {
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Proffie Style Parser</h1>
        
        <div class="input-section">
            <label for="codeInput">Paste your Proffie style code:</label>
            <textarea id="codeInput" placeholder="Paste your using Variable = Expression; or StylePtr<Expression>() code here"></textarea>
            <br><br>
            
            <div style="display: flex; align-items: center; gap: 15px; margin: 15px 0;">
                <div>
                    <label for="nameInput" style="margin-bottom: 5px;">Name:</label>
                    <input type="text" id="nameInput" placeholder="Enter style name" 
                           style="padding: 8px 12px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 8px; background: rgba(255, 255, 255, 0.1); color: #ffffff; font-size: 14px; width: 200px;">
                </div>
                
                <div>
                    <label style="margin-bottom: 5px; display: block;">Export Format:</label>
                    <div style="display: flex; gap: 10px;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="radio" name="exportFormat" value="style" id="styleRadio" checked>
                            <span>Style</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="radio" name="exportFormat" value="using" id="usingRadio">
                            <span>Using</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <button class="parse-btn" onclick="parseCode()">Parse Structure</button>
            <button class="export-btn" onclick="exportCode()">Copy Modified Code</button>
            <button class="parse-btn" onclick="clearForm()" style="background: linear-gradient(45deg, #e74c3c, #c0392b); margin-left: 10px;">Clear</button>
        </div>

        <div id="errorDisplay"></div>
        <div id="treeView" class="tree-view hidden"></div>
    </div>
    
    <!-- Remove Confirmation Modal -->
    <div id="removeModal" class="modal">
        <div class="modal-content">
            <h3>Confirm Removal</h3>
            <p>Are you sure you want to remove this parameter and all its children?</p>
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="cancelRemove()">Cancel</button>
                <button class="modal-btn primary" onclick="confirmRemove()">Remove</button>
            </div>
        </div>
    </div>
    <div id="addModal" class="modal">
        <div class="modal-content">
            <h3>Add New Parameter</h3>
            <label for="paramType">Parameter Type:</label>
            <select id="paramType" style="width: 100%; padding: 12px; margin-bottom: 15px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 8px; background: rgba(255, 255, 255, 0.1); color: #ffffff; font-size: 14px;">
                <option value="function">Function (e.g., Red, Blue, Layers)</option>
                <option value="value">Simple Value (e.g., 300, BLACK)</option>
            </select>
            
            <label for="paramName">Function Name (if function type):</label>
            <input type="text" id="paramName" placeholder="e.g., Red, Blue, Layers">
            
            <label for="paramValue">Value/Parameter:</label>
            <input type="text" id="paramValue" placeholder="e.g., 300, BLACK, or nested parameters">
            
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="closeAddModal()">Cancel</button>
                <button class="modal-btn primary" onclick="confirmAddParameter()">Add Parameter</button>
            </div>
        </div>
    </div>
	
	<div class="footer">
		Created by <span class="creator">JediMasterTech</span>
	</div>

    <script>
        let parsedStructure = null;
        let originalCode = '';
        let codePrefix = '';
        let codeSuffix = '';
        let codeFormat = '';
        let detectedFormat = '';
        let innerExpression = '';
        let aliasName = null;
        let leadingComments = '';
        let trailingComments = '';
        let collapsedNodes = new Set();
        let currentAddTarget = null; // Track which node we're adding to
        let currentRemoveTarget = null; // Track which node we're removing

        function detectWrapper(code) {
            // Remove leading and trailing whitespace for detection, but preserve original
            const trimmed = code.trim();
            
            // Try to match StylePtr with call: StylePtr<EXPR>()
            let stylePtrWithCallMatch = trimmed.match(/^(.*?)StylePtr<(.+?)>\(\)(.*?)$/s);
            if (stylePtrWithCallMatch) {
                const beforeMatch = code.match(/^(\s*.*?)StylePtr</s);
                const afterMatch = code.match(/>\(\)(.*?\s*)$/s);
                return {
                    format: 'styleptr_with_call',
                    expr: stylePtrWithCallMatch[2],
                    aliasName: null,
                    leadingComments: beforeMatch ? beforeMatch[1] : '',
                    trailingComments: afterMatch ? afterMatch[1] : ''
                };
            }
            
            // Try to match StylePtr without call: StylePtr<EXPR>
            let stylePtrNoCallMatch = trimmed.match(/^(.*?)StylePtr<(.+?)>(.*?)$/s);
            if (stylePtrNoCallMatch) {
                const beforeMatch = code.match(/^(\s*.*?)StylePtr</s);
                const afterMatch = code.match(/>([^>]*?\s*)$/s);
                return {
                    format: 'styleptr_no_call',
                    expr: stylePtrNoCallMatch[2],
                    aliasName: null,
                    leadingComments: beforeMatch ? beforeMatch[1] : '',
                    trailingComments: afterMatch ? afterMatch[1] : ''
                };
            }
            
            // Try to match using: using NAME = EXPR;
            let usingMatch = trimmed.match(/^(.*?)using\s+(\w+)\s*=\s*(.+?);?(.*?)$/s);
            if (usingMatch) {
                const beforeMatch = code.match(/^(\s*.*?)using\s+\w+\s*=/s);
                const afterMatch = code.match(/;?(.*?\s*)$/s);
                return {
                    format: 'using',
                    expr: usingMatch[3],
                    aliasName: usingMatch[2],
                    leadingComments: beforeMatch ? beforeMatch[1] : '',
                    trailingComments: afterMatch ? afterMatch[1] : ''
                };
            }
            
            // No recognizable wrapper - treat entire input as EXPR
            return {
                format: 'no_wrapper',
                expr: code,
                aliasName: null,
                leadingComments: '',
                trailingComments: ''
            };
        }

		// Make tryExpandParameter available globally for onclick handlers
        window.tryExpandParameter = function(nodeId) {
            // Find the input field for this node
            const inputElement = document.querySelector(`input[onchange*="${nodeId}"]`);
            if (!inputElement) return;
            
            const nestedCode = inputElement.value.trim();
            
            try {
                // Try to parse the field value as nested code
                const nestedStructure = parseExpression(nestedCode);
                
                // Only expand if it's actually a function (has nested structure)
                if (nestedStructure.type === 'function' && nestedStructure.parameters && nestedStructure.parameters.length > 0) {
                    // Store scroll position
                    const treeView = document.getElementById('treeView');
                    const scrollTop = treeView.scrollTop;
                    
                    // Replace the simple value with the parsed structure
                    replaceNodeStructure(parsedStructure, nodeId, nestedStructure);
                    
                    // Re-render the tree
                    displayTree();
                    
                    // Restore scroll position
                    setTimeout(() => {
                        treeView.scrollTop = scrollTop;
                    }, 0);
                } else {
                    showError(`"${nestedCode}" is not expandable nested code.`);
                    setTimeout(clearError, 3000);
                }
            } catch (error) {
                showError(`Cannot parse "${nestedCode}" as nested code: ${error.message}`);
                setTimeout(clearError, 3000);
            }
        };

        window.addParameter = function(nodeId) {
            currentAddTarget = nodeId;
            document.getElementById('addModal').style.display = 'block';
            document.getElementById('paramName').focus();
        };

        window.removeParameter = function(nodeId, event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            console.log('=== REMOVE ATTEMPT ===');
            console.log('Target node ID:', nodeId);
            console.log('Root node ID:', parsedStructure.id);
            
            // Check if this is the root node
            if (parsedStructure.id === nodeId) {
                showError('Cannot remove the root node.');
                setTimeout(clearError, 3000);
                return;
            }
            
            // Store the target and show custom modal
            currentRemoveTarget = nodeId;
            document.getElementById('removeModal').style.display = 'block';
        };

        function cancelRemove() {
            document.getElementById('removeModal').style.display = 'none';
            currentRemoveTarget = null;
        }

        function confirmRemove() {
            document.getElementById('removeModal').style.display = 'none';
            
            if (!currentRemoveTarget) return;
            
            console.log('User confirmed removal of:', currentRemoveTarget);
            console.log('Root has parameters:', !!parsedStructure.parameters);
            if (parsedStructure.parameters) {
                console.log('Root parameter count:', parsedStructure.parameters.length);
                parsedStructure.parameters.forEach((p, i) => {
                    console.log(`Root param ${i}: ID=${p.id}, type=${p.type}, name=${p.name || p.value}`);
                });
            }
            
            console.log('About to call removeFromParent...');
            const success = removeFromParent(parsedStructure, currentRemoveTarget);
            console.log('Final remove result:', success);
            
            if (success) {
                console.log('Redrawing tree...');
                const treeView = document.getElementById('treeView');
                treeView.innerHTML = '';
                displayTree();
                console.log('Tree redrawn successfully');
            } else {
                showError('Failed to remove parameter - node not found.');
                setTimeout(clearError, 3000);
            }
            
            currentRemoveTarget = null;
        }

        function removeFromParent(parent, targetId) {
            console.log(`\n--- Checking parent: ${parent.name || parent.type} (ID: ${parent.id}) ---`);
            
            if (parent.parameters && Array.isArray(parent.parameters)) {
                console.log(`Parent has ${parent.parameters.length} parameters`);
                
                // First check direct children
                for (let i = 0; i < parent.parameters.length; i++) {
                    const child = parent.parameters[i];
                    console.log(`  Child ${i}: ID="${child.id}" (looking for "${targetId}")`);
                    
                    if (child.id === targetId) {
                        console.log(`  *** FOUND TARGET! Removing from index ${i} ***`);
                        parent.parameters.splice(i, 1);
                        console.log(`  New parameter count: ${parent.parameters.length}`);
                        return true;
                    }
                }
                
                // Then recursively check grandchildren
                for (let i = 0; i < parent.parameters.length; i++) {
                    const child = parent.parameters[i];
                    if (child.parameters && child.parameters.length > 0) {
                        console.log(`  Recursing into child ${i}...`);
                        if (removeFromParent(child, targetId)) {
                            return true;
                        }
                    }
                }
            } else {
                console.log('Parent has no parameters or not an array');
            }
            return false;
        }

        window.copyParameter = function(nodeId) {
            const node = findNodeById(parsedStructure, nodeId);
            if (node) {
                const code = buildExpression(node);
                navigator.clipboard.writeText(code).then(() => {
                    showError('Parameter copied to clipboard!');
                    setTimeout(clearError, 2000);
                }).catch(err => {
                    showError('Failed to copy: ' + err.message);
                    setTimeout(clearError, 3000);
                });
            }
        };

        function findNodeById(node, targetId) {
            if (node.id === targetId) {
                return node;
            }
            
            if (node.parameters) {
                for (let param of node.parameters) {
                    const found = findNodeById(param, targetId);
                    if (found) return found;
                }
            }
            
            return null;
        }

        function removeNodeFromStructure(node, targetId) {
            // Don't allow removing the root
            if (node.id === targetId) {
                return false;
            }
            
            if (node.parameters) {
                const index = node.parameters.findIndex(p => p.id === targetId);
                if (index !== -1) {
                    node.parameters.splice(index, 1);
                    return true;
                }
                
                for (let param of node.parameters) {
                    if (removeNodeFromStructure(param, targetId)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function closeAddModal() {
            document.getElementById('addModal').style.display = 'none';
            document.getElementById('paramType').value = 'function';
            document.getElementById('paramName').value = '';
            document.getElementById('paramValue').value = '';
            currentAddTarget = null;
        }

        function confirmAddParameter() {
            const type = document.getElementById('paramType').value;
            const name = document.getElementById('paramName').value.trim();
            const value = document.getElementById('paramValue').value.trim();
            
            if (type === 'function' && !name) {
                showError('Function name is required for function type parameters.');
                return;
            }
            
            if (!value) {
                showError('Value/Parameter is required.');
                return;
            }
            
            let newParam;
            if (type === 'function') {
                newParam = {
                    type: 'function',
                    name: name,
                    parameters: value ? parseParameters(value) : [],
                    id: Math.random().toString(36).substr(2, 9)
                };
            } else {
                newParam = {
                    type: 'value',
                    value: value,
                    id: Math.random().toString(36).substr(2, 9)
                };
            }
            
            addParameterToNode(parsedStructure, currentAddTarget, newParam);
            displayTree();
            closeAddModal();
        }

        function addParameterToNode(node, targetId, newParam) {
            if (node.id === targetId) {
                if (!node.parameters) {
                    node.parameters = [];
                }
                node.parameters.push(newParam);
                return true;
            }
            
            if (node.parameters) {
                for (let param of node.parameters) {
                    if (addParameterToNode(param, targetId, newParam)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function replaceNodeStructure(node, targetId, newStructure) {
            if (node.id === targetId) {
                Object.assign(node, newStructure);
                return true;
            }
            
            if (node.parameters) {
                for (let param of node.parameters) {
                    if (replaceNodeStructure(param, targetId, newStructure)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorDisplay');
            errorDiv.innerHTML = `<div class="error">${message}</div>`;
        }

        function clearError() {
            document.getElementById('errorDisplay').innerHTML = '';
        }

        function parseCode() {
            const code = document.getElementById('codeInput').value.trim();
            
            if (!code) {
                showError('Please enter some code to parse.');
                return;
            }

            clearError();
            originalCode = code;

            try {
                // New wrapper detection
                const detection = detectWrapper(code);
                detectedFormat = detection.format;
                innerExpression = detection.expr;
                aliasName = detection.aliasName;
                leadingComments = detection.leadingComments;
                trailingComments = detection.trailingComments;
                
                // Update UI based on detection
                const nameInput = document.getElementById('nameInput');
                if (aliasName) {
                    nameInput.value = aliasName;
                } else if (!nameInput.value.trim()) {
                    nameInput.value = '';
                }
                
                // Set appropriate radio button
                if (detectedFormat === 'using') {
                    document.getElementById('usingRadio').checked = true;
                } else {
                    document.getElementById('styleRadio').checked = true;
                }
                
                parsedStructure = parseExpression(innerExpression);
                
                // Legacy fallback for old format
                let usingMatch = code.match(/(.*?)(using\s+(\w+)\s*=\s*(.+?);)(.*)/s);
                let stylePtrMatch = code.match(/(.*?)(StylePtr<(.+?)>\(\))(.*)/s);
                
                if (usingMatch && !detectedFormat) {
                    codeFormat = 'using';
                    codePrefix = usingMatch[1];
                    const variableName = usingMatch[3];
                    const expression = usingMatch[4];
                    codeSuffix = usingMatch[5];
                    
                    parsedStructure = parseExpression(expression);
                    parsedStructure.variableName = variableName;
                } else if (stylePtrMatch && !detectedFormat) {
                    codeFormat = 'styleptr';
                    codePrefix = stylePtrMatch[1];
                    const expression = stylePtrMatch[3];
                    codeSuffix = stylePtrMatch[4];
                    
                    parsedStructure = parseExpression(expression);
                } else if (!detectedFormat) {
                    showError('No valid code pattern found. Looking for either "using Variable = Expression;" or "StylePtr<Expression>()"');
                    return;
                }
                
                initializeOriginalValues(parsedStructure);
                displayTree();
            } catch (error) {
                showError('Parse error: ' + error.message);
            }
        }

        function parseExpression(expr) {
            expr = expr.trim();
            
            const funcMatch = expr.match(/^(\w+)<(.*)>$/s);
            if (funcMatch) {
                const funcName = funcMatch[1];
                const params = funcMatch[2];
                
                return {
                    type: 'function',
                    name: funcName,
                    parameters: parseParameters(params),
                    id: Math.random().toString(36).substr(2, 9)
                };
            }
            
            return {
                type: 'value',
                value: expr,
                id: Math.random().toString(36).substr(2, 9)
            };
        }

        function parseParameters(params) {
            if (!params.trim()) return [];
            
            const result = [];
            let current = '';
            let depth = 0;
            let inString = false;
            let stringChar = '';
            
            for (let i = 0; i < params.length; i++) {
                const char = params[i];
                
                if (!inString && (char === '"' || char === "'")) {
                    inString = true;
                    stringChar = char;
                } else if (inString && char === stringChar) {
                    inString = false;
                    stringChar = '';
                } else if (!inString) {
                    if (char === '<') depth++;
                    else if (char === '>') depth--;
                    else if (char === ',' && depth === 0) {
                        if (current.trim()) {
                            result.push(parseExpression(current.trim()));
                        }
                        current = '';
                        continue;
                    }
                }
                
                current += char;
            }
            
            if (current.trim()) {
                result.push(parseExpression(current.trim()));
            }
            
            return result;
        }

        function displayTree() {
            const treeView = document.getElementById('treeView');
            treeView.innerHTML = '';
            treeView.classList.remove('hidden');
            
            const rootNode = createNodeElement(parsedStructure, 0);
            treeView.appendChild(rootNode);
        }

		 function createNodeElement(node, depth) {
			const nodeDiv = document.createElement('div');
			nodeDiv.className = 'node';
			
			if (node.type === 'function') {
				const header = document.createElement('div');
				header.className = 'node-header';
				header.onclick = () => toggleNode(node.id);
				
				const hasChildren = node.parameters && node.parameters.length > 0;
				const expandIcon = document.createElement('span');
				expandIcon.className = 'expand-icon';
				expandIcon.textContent = hasChildren ? 'â–¼' : 'â€¢';
				expandIcon.id = `icon-${node.id}`;
				
				const params = document.createElement('span');
				params.className = 'parameters';
				
				const simpleParams = node.parameters?.filter(p => p.type === 'value') || [];
				if (simpleParams.length > 0) {
					const paramGroups = simpleParams.map(p => {
						const originalValue = p.originalValue || p.value;
						const isModified = p.value !== originalValue;
						const btnClass = isModified ? 'action-btn expand-btn modified' : 'action-btn expand-btn';
						
						return `<span class="parameter-group">
							<input type="text" class="parameter-input" value="${escapeHtml(p.value)}" 
								onchange="updateParameterWithTracking('${p.id}', this.value)" 
								data-original="${escapeHtml(originalValue)}">
							<button class="${btnClass}" onclick="window.tryExpandParameter('${p.id}')" title="Expand as nested code">â†—</button>
						</span>`;
					});
					
					params.innerHTML = paramGroups.join(' ');
				}
				
				// Add action buttons container
				const buttonsContainer = document.createElement('span');
				buttonsContainer.className = 'buttons-group';
				
				const isModified = node.parameters?.some(p => p.type === 'value' && p.value !== (p.originalValue || p.value));

				const addBtn = document.createElement('button');
				addBtn.className = 'action-btn';
				addBtn.innerHTML = '+';
				addBtn.title = 'Add parameter';
				addBtn.onclick = (e) => {
					e.stopPropagation();
					window.addParameter(node.id);
				};
				buttonsContainer.appendChild(addBtn);
				
				if (depth > 0) {
					const removeBtn = document.createElement('button');
					removeBtn.className = 'action-btn';
					removeBtn.innerHTML = 'âˆ’';
					removeBtn.title = 'Remove this function';
					removeBtn.onclick = (e) => {
						window.removeParameter(node.id, e);
					};
					buttonsContainer.appendChild(removeBtn);
				}
				
				const copyBtn = document.createElement('button');
				copyBtn.className = 'action-btn';
				copyBtn.innerHTML = 'ðŸ“‹';
				copyBtn.title = 'Copy this function';
				copyBtn.onclick = (e) => {
					e.stopPropagation();
					window.copyParameter(node.id);
				};
				buttonsContainer.appendChild(copyBtn);
				
				const paramContainer = document.createElement('div');
				paramContainer.className = 'param-container';

				const topLine = document.createElement('div');
				topLine.className = 'param-top-line';

				const funcName = document.createElement('span');
				funcName.className = 'function-name';
				funcName.textContent = node.name;

				topLine.appendChild(funcName);

				const paramWrap = document.createElement('div');
				paramWrap.className = 'param-wrap';
				paramWrap.appendChild(params);
				paramWrap.appendChild(buttonsContainer);

				paramContainer.appendChild(topLine);
				paramContainer.appendChild(paramWrap);

				header.appendChild(expandIcon);
				header.appendChild(paramContainer);
				
				nodeDiv.appendChild(header);
				
				const complexParams = node.parameters?.filter(p => p.type === 'function') || [];
				if (complexParams.length > 0) {
					const children = document.createElement('div');
					children.className = 'node-children';
					children.id = `children-${node.id}`;
					
					const shouldBeCollapsed = collapsedNodes.has(node.id);
					if (shouldBeCollapsed) {
						children.classList.add('hidden');
						expandIcon.textContent = 'â–¶';
					}
					
					complexParams.forEach(child => {
						children.appendChild(createNodeElement(child, depth + 1));
					});
					
					nodeDiv.appendChild(children);
				}
			} else {
				// Value node
				const header = document.createElement('div');
				header.className = 'node-header';
				
				const expandIcon = document.createElement('span');
				expandIcon.className = 'expand-icon';
				expandIcon.textContent = 'â€¢';
				
				const valueGroup = document.createElement('span');
				valueGroup.className = 'parameter-group';
				
				const value = document.createElement('input');
				value.type = 'text';
				value.className = 'parameter-input';
				value.value = node.value;
				value.setAttribute('data-original', node.originalValue || node.value);
				value.onchange = () => updateParameterWithTracking(node.id, value.value);
				value.style.minWidth = '200px';
				
				const isModified = node.value !== (node.originalValue || node.value);
				const expandBtn = document.createElement('button');
				expandBtn.className = isModified ? 'action-btn expand-btn modified' : 'action-btn expand-btn';
				expandBtn.innerHTML = 'â†—';
				expandBtn.onclick = () => window.tryExpandParameter(node.id);
				expandBtn.title = 'Try to expand as nested code';
				
				const removeBtn = document.createElement('button');
				removeBtn.className = 'action-btn';
				removeBtn.innerHTML = 'âˆ’';
				removeBtn.title = 'Remove this value';
				removeBtn.onclick = (e) => window.removeParameter(node.id, e);
				
				const copyBtn = document.createElement('button');
				copyBtn.className = 'action-btn';
				copyBtn.innerHTML = 'ðŸ“‹';
				copyBtn.title = 'Copy this value';
				copyBtn.onclick = () => window.copyParameter(node.id);
				
				valueGroup.appendChild(value);
				valueGroup.appendChild(expandBtn);
				
				if (depth > 0) {
					valueGroup.appendChild(removeBtn);
				}
				
				valueGroup.appendChild(copyBtn);
				
				header.appendChild(expandIcon);
				header.appendChild(valueGroup);
				nodeDiv.appendChild(header);
			}
			
			return nodeDiv;
		}

        function toggleNode(nodeId) {
            const children = document.getElementById(`children-${nodeId}`);
            const icon = document.getElementById(`icon-${nodeId}`);
            
            if (children) {
                const isCurrentlyHidden = children.classList.contains('hidden');
                
                if (isCurrentlyHidden) {
                    children.classList.remove('hidden');
                    icon.textContent = 'â–¼';
                    collapsedNodes.delete(nodeId);
                } else {
                    children.classList.add('hidden');
                    icon.textContent = 'â–¶';
                    collapsedNodes.add(nodeId);
                }
            }
        }

        function updateParameterWithTracking(nodeId, newValue) {
            updateNodeValue(parsedStructure, nodeId, newValue);
            
            const inputElement = document.querySelector(`input[onchange*="${nodeId}"]`);
            if (inputElement) {
                const originalValue = inputElement.getAttribute('data-original');
                const expandBtn = inputElement.nextElementSibling;
                if (expandBtn && expandBtn.classList.contains('expand-btn')) {
                    if (newValue !== originalValue) {
                        expandBtn.classList.add('modified');
                    } else {
                        expandBtn.classList.remove('modified');
                    }
                }
            }
        }

        function initializeOriginalValues(node) {
            if (!node.originalValue && node.value) {
                node.originalValue = node.value;
            }
            if (node.parameters) {
                node.parameters.forEach(initializeOriginalValues);
            }
        }

        function updateNodeValue(node, targetId, newValue) {
            if (node.id === targetId) {
                node.value = newValue;
                return true;
            }
            
            if (node.parameters) {
                for (let param of node.parameters) {
                    if (updateNodeValue(param, targetId, newValue)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function exportCode() {
            if (!parsedStructure) {
                showError('Please parse some code first.');
                return;
            }
            
            const nameInput = document.getElementById('nameInput');
            const styleName = nameInput.value.trim();
            
            if (!styleName) {
                showError('Please enter a name before exporting.');
                nameInput.focus();
                return;
            }
            
            const exportFormat = document.querySelector('input[name="exportFormat"]:checked').value;
            const modifiedExpr = buildExpression(parsedStructure);
            
            let mainOutput;
            if (exportFormat === 'using') {
                mainOutput = `using ${styleName} = ${modifiedExpr};`;
            } else {
                mainOutput = `StylePtr<${modifiedExpr}>()`;
            }
            
            const footer = `\n/*\nAdd to preset as StylePtr<${styleName}>()\n--------------------------------------------------------------------------\n*/\n`;
            
            let finalCode;
            if (detectedFormat) {
                // Use new wrapper system
                finalCode = leadingComments + mainOutput + trailingComments + footer;
            } else {
                // Legacy fallback
                let newStatement;
                if (codeFormat === 'using') {
                    newStatement = `using ${parsedStructure.variableName} = ${buildExpression(parsedStructure)};`;
                } else if (codeFormat === 'styleptr') {
                    newStatement = `StylePtr<${buildExpression(parsedStructure)}>()`;
                }
                finalCode = codePrefix + newStatement + codeSuffix + footer;
            }
            
            navigator.clipboard.writeText(finalCode).then(() => {
                const btn = document.querySelector('.export-btn');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = 'linear-gradient(45deg, #27ae60, #2ecc71)';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = 'linear-gradient(45deg, #3498db, #2980b9)';
                }, 2000);
            }).catch(err => {
                showError('Failed to copy to clipboard: ' + err.message);
            });
        }

        function buildExpression(node) {
            if (node.type === 'value') {
                return node.value;
            } else if (node.type === 'function') {
                const params = node.parameters?.map(p => buildExpression(p)).join(',') || '';
                return `${node.name}<${params}>`;
            }
            return '';
        }

        function clearForm() {
            document.getElementById('codeInput').value = '';
            document.getElementById('nameInput').value = '';
            document.getElementById('treeView').innerHTML = '';
            document.getElementById('treeView').classList.add('hidden');
            document.getElementById('styleRadio').checked = true;
            clearError();
            
            parsedStructure = null;
            originalCode = '';
            codePrefix = '';
            codeSuffix = '';
            codeFormat = '';
            detectedFormat = '';
            innerExpression = '';
            aliasName = null;
            leadingComments = '';
            trailingComments = '';
            collapsedNodes.clear();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const addModal = document.getElementById('addModal');
            const removeModal = document.getElementById('removeModal');
            if (event.target === addModal) {
                closeAddModal();
            } else if (event.target === removeModal) {
                cancelRemove();
            }
        }

		document.addEventListener('DOMContentLoaded', function () {
			// Handle Enter key in modal inputs
			const inputs = document.querySelectorAll('#addModal input');
			inputs.forEach(input => {
				input.addEventListener('keypress', function (e) {
					if (e.key === 'Enter') {
						confirmAddParameter();
					}
				});
			});

			// Handle Enter key in main textarea
			const codeInput = document.getElementById('codeInput');
			codeInput.addEventListener('keydown', function (e) {
				if (e.key === 'Enter' && !e.shiftKey) {
					e.preventDefault(); // prevent newline
					parseCode(); // trigger the same function as Parse Structure button
				}
			});

			// Handle Enter key in modified parameter input fields
			document.addEventListener('keydown', function (e) {
				const target = e.target;
				if (
					target.classList.contains('parameter-input') &&
					e.key === 'Enter' &&
					!e.shiftKey
				) {
					e.preventDefault();
					const newValue = target.value;
					const originalValue = target.getAttribute('data-original');

					if (newValue !== originalValue) {
						const paramId = target
							.getAttribute('onchange')
							?.match(/['"](.+?)['"]/)[1]; // Extract param ID
						if (paramId) {
							window.tryExpandParameter(paramId);
						}
					}
				}
			});
		});
    </script>
</body>
</html>
                