<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proffie Style Parser</title>
	<link rel="stylesheet" href="./assets/css/style.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #e0e0e0;
        }

        textarea {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: all 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
        }

        .parse-btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
        }

        .parse-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .export-btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
		
		.buttons-group {
			display: flex;
			flex-wrap: wrap;
			gap: 3px;
			margin-left: 10px;
		}

        .tree-view {
            margin-top: 30px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
        }

        .node {
            margin: 5px 0;
        }

        .node-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 3px solid #00d4ff;
        }

        .node-header:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .expand-icon {
            margin-right: 10px;
            font-family: monospace;
            font-size: 12px;
            width: 15px;
            color: #00d4ff;
        }

        .function-name {
            font-weight: 600;
            color: #ff6b6b;
			flex-shrink: 0;
			white-space: nowrap;
            margin-right: 10px;
        }

        .parameters {
            color: #4ecdc4;
            font-size: 0.9rem;
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
			flex: 1 1 auto;
			min-width: 0;
        }

        .parameter-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            padding: 4px 8px;
            color: #ffffff;
            font-size: 0.9rem;
            margin: 0 4px;
            min-width: 60px;
        }

        .parameter-input:focus {
            outline: none;
            border-color: #00d4ff;
        }
		
		.param-buttons-wrap {
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
			align-items: center;
			flex: 1 1 auto;
		}
		
		.param-container {
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			flex: 1;
			min-width: 0;
		}

		.param-top-line {
			display: flex;
			flex-direction: row;
			align-items: center;
			flex-wrap: wrap;
			gap: 10px;
		}

		.param-wrap {
			flex: 1;
			min-width: 250px;
			display: flex;
			flex-wrap: wrap;
			gap: 6px;
		}

        .action-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 3px;
            color: #ffffff;
            font-size: 0.8rem;
            padding: 0;
            margin: 0 1px;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.6;
            width: 22px;
            height: 22px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            opacity: 1;
            transform: scale(1.05);
        }

        .expand-btn.modified {
            opacity: 1;
            background: rgba(0, 212, 255, 0.3);
        }

        .expand-btn.modified:hover {
            background: rgba(0, 212, 255, 0.5);
        }

        .parameter-group {
            display: flex;
            align-items: center;
            margin: 0 2px;
			flex: 1 0 auto;
			min-width: 60px;
        }

        .node-children {
            margin-left: 30px;
            margin-top: 10px;
            border-left: 2px solid rgba(0, 212, 255, 0.3);
            padding-left: 15px;
        }

        .hidden {
            display: none;
        }

        .error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            color: #ff6b6b;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 15% auto;
            padding: 30px;
            border-radius: 15px;
            width: 500px;
            max-width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .modal h3 {
            color: #00d4ff;
            margin-bottom: 20px;
        }

        .modal label {
            display: block;
            margin-bottom: 8px;
            color: #e0e0e0;
            font-weight: 600;
        }

        .modal input[type="text"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 14px;
        }

        .modal input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-btn.primary {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .modal-btn.secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .modal-btn:hover {
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Proffie Style Parser</h1>
        
        <div class="input-section">
            <label for="codeInput">Paste your Proffie style code:</label>
            <textarea id="codeInput" placeholder="Paste your using RainbowSwitch = Layers<...> code here"></textarea>
            <br><br>
            <button class="parse-btn" onclick="parseCode()">Parse Structure</button>
            <button class="export-btn" onclick="exportCode()">Copy Modified Code</button>
            <button class="parse-btn" onclick="clearForm()" style="background: linear-gradient(45deg, #e74c3c, #c0392b); margin-left: 10px;">Clear</button>
        </div>

        <div id="errorDisplay"></div>
        <div id="treeView" class="tree-view hidden"></div>
    </div>
    
    <!-- Remove Confirmation Modal -->
    <div id="removeModal" class="modal">
        <div class="modal-content">
            <h3>Confirm Removal</h3>
            <p>Are you sure you want to remove this parameter and all its children?</p>
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="cancelRemove()">Cancel</button>
                <button class="modal-btn primary" onclick="confirmRemove()">Remove</button>
            </div>
        </div>
    </div>
    <div id="addModal" class="modal">
        <div class="modal-content">
            <h3>Add New Parameter</h3>
            <label for="paramType">Parameter Type:</label>
            <select id="paramType" style="width: 100%; padding: 12px; margin-bottom: 15px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 8px; background: rgba(255, 255, 255, 0.1); color: #ffffff; font-size: 14px;">
                <option value="function">Function (e.g., Red, Blue, Layers)</option>
                <option value="value">Simple Value (e.g., 300, BLACK)</option>
            </select>
            
            <label for="paramName">Function Name (if function type):</label>
            <input type="text" id="paramName" placeholder="e.g., Red, Blue, Layers">
            
            <label for="paramValue">Value/Parameter:</label>
            <input type="text" id="paramValue" placeholder="e.g., 300, BLACK, or nested parameters">
            
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="closeAddModal()">Cancel</button>
                <button class="modal-btn primary" onclick="confirmAddParameter()">Add Parameter</button>
            </div>
        </div>
    </div>
	
	<div class="footer">
		Created by <span class="creator">JediMasterTech</span>
	</div>

    <script>
        let parsedStructure = null;
        let originalCode = '';
        let codePrefix = '';
        let codeSuffix = '';
        let codeFormat = '';
        let collapsedNodes = new Set();
        let currentAddTarget = null; // Track which node we're adding to
        let currentRemoveTarget = null; // Track which node we're removing

        // Make functions available globally
        window.tryExpandParameter = function(nodeId) {
            const inputElement = document.querySelector(`input[data-id="${nodeId}"]`);
            if (!inputElement) return;
            
            const nestedCode = inputElement.value.trim();
            
            try {
                const nestedStructure = parseExpression(nestedCode);
                
                if (nestedStructure.type === 'function' && nestedStructure.parameters && nestedStructure.parameters.length > 0) {
                    const treeView = document.getElementById('treeView');
                    const scrollTop = treeView.scrollTop;
                    
                    replaceNodeStructure(parsedStructure, nodeId, nestedStructure);
                    displayTree();
                    
                    setTimeout(() => {
                        treeView.scrollTop = scrollTop;
                    }, 0);
                } else {
                    showError(`"${nestedCode}" is not expandable nested code.`);
                    setTimeout(clearError, 3000);
                }
            } catch (error) {
                showError(`Cannot parse "${nestedCode}" as nested code: ${error.message}`);
                setTimeout(clearError, 3000);
            }
        };

        window.addParameter = function(nodeId) {
            currentAddTarget = nodeId;
            document.getElementById('addModal').style.display = 'block';
            document.getElementById('paramName').focus();
        };

        window.removeParameter = function(nodeId, event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            console.log('=== REMOVE ATTEMPT ===');
            console.log('Target node ID:', nodeId);
            console.log('Root node ID:', parsedStructure.id);
            
            // Check if this is the root node
            if (parsedStructure.id === nodeId) {
                showError('Cannot remove the root node.');
                setTimeout(clearError, 3000);
                return;
            }
            
            // Store the target and show custom modal
            currentRemoveTarget = nodeId;
            document.getElementById('removeModal').style.display = 'block';
        };

        function cancelRemove() {
            document.getElementById('removeModal').style.display = 'none';
            currentRemoveTarget = null;
        }

        function confirmRemove() {
            document.getElementById('removeModal').style.display = 'none';
            
            if (!currentRemoveTarget) return;
            
            console.log('User confirmed removal of:', currentRemoveTarget);
            console.log('Root has parameters:', !!parsedStructure.parameters);
            if (parsedStructure.parameters) {
                console.log('Root parameter count:', parsedStructure.parameters.length);
                parsedStructure.parameters.forEach((p, i) => {
                    console.log(`Root param ${i}: ID=${p.id}, type=${p.type}, name=${p.name || p.value}`);
                });
            }
            
            console.log('About to call removeFromParent...');
            const success = removeFromParent(parsedStructure, currentRemoveTarget);
            console.log('Final remove result:', success);
            
            if (success) {
                console.log('Redrawing tree...');
                const treeView = document.getElementById('treeView');
                treeView.innerHTML = '';
                displayTree();
                console.log('Tree redrawn successfully');
            } else {
                showError('Failed to remove parameter - node not found.');
                setTimeout(clearError, 3000);
            }
            
            currentRemoveTarget = null;
        }

        function removeFromParent(parent, targetId) {
            console.log(`\n--- Checking parent: ${parent.name || parent.type} (ID: ${parent.id}) ---`);
            
            if (parent.parameters && Array.isArray(parent.parameters)) {
                console.log(`Parent has ${parent.parameters.length} parameters`);
                
                // First check direct children
                for (let i = 0; i < parent.parameters.length; i++) {
                    const child = parent.parameters[i];
                    console.log(`  Child ${i}: ID="${child.id}" (looking for "${targetId}")`);
                    
                    if (child.id === targetId) {
                        console.log(`  *** FOUND TARGET! Removing from index ${i} ***`);
                        parent.parameters.splice(i, 1);
                        console.log(`  New parameter count: ${parent.parameters.length}`);
                        return true;
                    }
                }
                
                // Then recursively check grandchildren
                for (let i = 0; i < parent.parameters.length; i++) {
                    const child = parent.parameters[i];
                    if (child.parameters && child.parameters.length > 0) {
                        console.log(`  Recursing into child ${i}...`);
                        if (removeFromParent(child, targetId)) {
                            return true;
                        }
                    }
                }
            } else {
                console.log('Parent has no parameters or not an array');
            }
            return false;
        }

        window.copyParameter = function(nodeId) {
            const node = findNodeById(parsedStructure, nodeId);
            if (node) {
                const code = buildExpression(node);
                navigator.clipboard.writeText(code).then(() => {
                    showError('Parameter copied to clipboard!');
                    setTimeout(clearError, 2000);
                }).catch(err => {
                    showError('Failed to copy: ' + err.message);
                    setTimeout(clearError, 3000);
                });
            }
        };

        function findNodeById(node, targetId) {
            if (node.id === targetId) {
                return node;
            }
            
            if (node.parameters) {
                for (let param of node.parameters) {
                    const found = findNodeById(param, targetId);
                    if (found) return found;
                }
            }
            
            return null;
        }

        function removeNodeFromStructure(node, targetId) {
            // Don't allow removing the root
            if (node.id === targetId) {
                return false;
            }
            
            if (node.parameters) {
                const index = node.parameters.findIndex(p => p.id === targetId);
                if (index !== -1) {
                    node.parameters.splice(index, 1);
                    return true;
                }
                
                for (let param of node.parameters) {
                    if (removeNodeFromStructure(param, targetId)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function closeAddModal() {
            document.getElementById('addModal').style.display = 'none';
            document.getElementById('paramType').value = 'function';
            document.getElementById('paramName').value = '';
            document.getElementById('paramValue').value = '';
            currentAddTarget = null;
        }

        function confirmAddParameter() {
            const type = document.getElementById('paramType').value;
            const name = document.getElementById('paramName').value.trim();
            const value = document.getElementById('paramValue').value.trim();
            
            if (type === 'function' && !name) {
                showError('Function name is required for function type parameters.');
                return;
            }
            
            if (!value) {
                showError('Value/Parameter is required.');
                return;
            }
            
            let newParam;
            if (type === 'function') {
                newParam = {
                    type: 'function',
                    name: name,
                    parameters: value ? parseParameters(value) : [],
                    id: Math.random().toString(36).substr(2, 9)
                };
            } else {
                newParam = {
                    type: 'value',
                    value: value,
                    id: Math.random().toString(36).substr(2, 9)
                };
            }
            
            addParameterToNode(parsedStructure, currentAddTarget, newParam);
            displayTree();
            closeAddModal();
        }

        function addParameterToNode(node, targetId, newParam) {
            if (node.id === targetId) {
                if (!node.parameters) {
                    node.parameters = [];
                }
                node.parameters.push(newParam);
                return true;
            }
            
            if (node.parameters) {
                for (let param of node.parameters) {
                    if (addParameterToNode(param, targetId, newParam)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function replaceNodeStructure(node, targetId, newStructure) {
            if (node.id === targetId) {
                Object.assign(node, newStructure);
                return true;
            }
            
            if (node.parameters) {
                for (let param of node.parameters) {
                    if (replaceNodeStructure(param, targetId, newStructure)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorDisplay');
            errorDiv.innerHTML = `<div class="error">${message}</div>`;
        }

        function clearError() {
            document.getElementById('errorDisplay').innerHTML = '';
        }

        function parseCode() {
            const code = document.getElementById('codeInput').value.trim();
            
            if (!code) {
                showError('Please enter some code to parse.');
                return;
            }

            clearError();
            originalCode = code;

            try {
                let usingMatch = code.match(/(.*?)(using\s+(\w+)\s*=\s*(.+?);)(.*)/s);
                let stylePtrMatch = code.match(/(.*?)(StylePtr<(.+?)>\(\))(.*)/s);
                
                if (usingMatch) {
                    codeFormat = 'using';
                    codePrefix = usingMatch[1];
                    const variableName = usingMatch[3];
                    const expression = usingMatch[4];
                    codeSuffix = usingMatch[5];
                    
                    parsedStructure = parseExpression(expression);
                    parsedStructure.variableName = variableName;
                } else if (stylePtrMatch) {
                    codeFormat = 'styleptr';
                    codePrefix = stylePtrMatch[1];
                    const expression = stylePtrMatch[3];
                    codeSuffix = stylePtrMatch[4];
                    
                    parsedStructure = parseExpression(expression);
                } else {
                    showError('No valid code pattern found. Looking for either "using Variable = Expression;" or "StylePtr<Expression>()"');
                    return;
                }
                
                initializeOriginalValues(parsedStructure);
                displayTree();
            } catch (error) {
                showError('Parse error: ' + error.message);
            }
        }

        function parseExpression(expr) {
            expr = expr.trim();
            
            const funcMatch = expr.match(/^(\w+)<(.*)>$/s);
            if (funcMatch) {
                const funcName = funcMatch[1];
                const params = funcMatch[2];
                
                return {
                    type: 'function',
                    name: funcName,
                    parameters: parseParameters(params),
                    id: Math.random().toString(36).substr(2, 9)
                };
            }
            
            return {
                type: 'value',
                value: expr,
                id: Math.random().toString(36).substr(2, 9)
            };
        }

        function parseParameters(params) {
            if (!params.trim()) return [];
            
            const result = [];
            let current = '';
            let depth = 0;
            let inString = false;
            let stringChar = '';
            
            for (let i = 0; i < params.length; i++) {
                const char = params[i];
                
                if (!inString && (char === '"' || char === "'")) {
                    inString = true;
                    stringChar = char;
                } else if (inString && char === stringChar) {
                    inString = false;
                    stringChar = '';
                } else if (!inString) {
                    if (char === '<') depth++;
                    else if (char === '>') depth--;
                    else if (char === ',' && depth === 0) {
                        if (current.trim()) {
                            result.push(parseExpression(current.trim()));
                        }
                        current = '';
                        continue;
                    }
                }
                
                current += char;
            }
            
            if (current.trim()) {
                result.push(parseExpression(current.trim()));
            }
            
            return result;
        }

        function displayTree() {
            const treeView = document.getElementById('treeView');
            treeView.innerHTML = '';
            treeView.classList.remove('hidden');
            
            const rootNode = createNodeElement(parsedStructure, 0);
            treeView.appendChild(rootNode);
        }

        function createNodeElement(node, depth) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'node';
            
            if (node.type === 'function') {
                const header = document.createElement('div');
                header.className = 'node-header';
                header.onclick = () => toggleNode(node.id);
                
                const hasChildren = node.parameters && node.parameters.length > 0;
                const expandIcon = document.createElement('span');
                expandIcon.className = 'expand-icon';
                expandIcon.textContent = hasChildren ? '▼' : '•';
                expandIcon.id = `icon-${node.id}`;
                
                const params = document.createElement('span');
                params.className = 'parameters';
                
                const simpleParams = node.parameters?.filter(p => p.type === 'value') || [];
                if (simpleParams.length > 0) {
                    const paramGroups = simpleParams.map(p => {
                        const originalValue = p.originalValue || p.value;
                        const isModified = p.value !== originalValue;
                        const btnClass = isModified ? 'expand-btn modified' : 'expand-btn';
                        
                        return `<span class="parameter-group">
                            <input type="text"
							   class="parameter-input"
							   value="${escapeHtml(p.value)}"
							   data-id="${p.id}"
							   data-original="${escapeHtml(originalValue)}"
							   onchange="updateParameterWithTracking('${p.id}', this.value)">
                         </span>`;
                    });
                    
                    params.innerHTML = paramGroups.join(' ');
                }
                
                // Add action buttons container
                const buttonsContainer = document.createElement('span');
                buttonsContainer.className = 'buttons-group';
                
				const isModified = node.parameters?.some(p => p.type === 'value' && p.value !== (p.originalValue || p.value));
				
				const expandBtn = document.createElement('button');
				expandBtn.className = isModified ? 'action-btn expand-btn modified' : 'action-btn expand-btn';
				expandBtn.innerHTML = '↗';
				expandBtn.title = 'Expand as nested code';
				expandBtn.onclick = (e) => {
					e.stopPropagation();
					window.tryExpandParameter(node.id);
				};
				buttonsContainer.appendChild(expandBtn);

                const addBtn = document.createElement('button');
                addBtn.className = 'action-btn';
                addBtn.innerHTML = '+';
                addBtn.title = 'Add parameter';
                addBtn.onclick = (e) => {
                    e.stopPropagation();
                    window.addParameter(node.id);
                };
                buttonsContainer.appendChild(addBtn);
                
                if (depth > 0) {
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'action-btn';
                    removeBtn.innerHTML = '−';
                    removeBtn.title = 'Remove this function';
                    removeBtn.onclick = (e) => {
                        window.removeParameter(node.id, e);
                    };
                    buttonsContainer.appendChild(removeBtn);
                }
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'action-btn';
                copyBtn.innerHTML = '📋';
                copyBtn.title = 'Copy this function';
                copyBtn.onclick = (e) => {
                    e.stopPropagation();
                    window.copyParameter(node.id);
                };
                buttonsContainer.appendChild(copyBtn);
                
				const paramContainer = document.createElement('div');
				paramContainer.className = 'param-container';

				const topLine = document.createElement('div');
				topLine.className = 'param-top-line';

				const funcName = document.createElement('span');
				funcName.className = 'function-name';
				funcName.textContent = node.name;

				topLine.appendChild(funcName);

				const paramWrap = document.createElement('div');
				paramWrap.className = 'param-wrap';
				paramWrap.appendChild(params);
				paramWrap.appendChild(buttonsContainer);

				paramContainer.appendChild(topLine);
				paramContainer.appendChild(paramWrap);

				header.appendChild(expandIcon);
				header.appendChild(paramContainer);
                
                nodeDiv.appendChild(header);
                
                const complexParams = node.parameters?.filter(p => p.type === 'function') || [];
                if (complexParams.length > 0) {
                    const children = document.createElement('div');
                    children.className = 'node-children';
                    children.id = `children-${node.id}`;
                    
                    const shouldBeCollapsed = collapsedNodes.has(node.id);
                    if (shouldBeCollapsed) {
                        children.classList.add('hidden');
                        expandIcon.textContent = '▶';
                    }
                    
                    complexParams.forEach(child => {
                        children.appendChild(createNodeElement(child, depth + 1));
                    });
                    
                    nodeDiv.appendChild(children);
                }
            } else {
                // Value node
                const header = document.createElement('div');
                header.className = 'node-header';
                
                const expandIcon = document.createElement('span');
                expandIcon.className = 'expand-icon';
                expandIcon.textContent = '•';
                
                const valueGroup = document.createElement('span');
                valueGroup.className = 'parameter-group';
                
                const value = document.createElement('input');
                value.type = 'text';
                value.className = 'parameter-input';
                value.value = node.value;
                value.setAttribute('data-original', node.originalValue || node.value);
                value.onchange = () => updateParameterWithTracking(node.id, value.value);
                value.style.minWidth = '200px';
                
                const isModified = node.value !== (node.originalValue || node.value);
                const expandBtn = document.createElement('button');
                expandBtn.className = isModified ? 'action-btn expand-btn modified' : 'action-btn expand-btn';
                expandBtn.innerHTML = '↗';
                expandBtn.onclick = () => window.tryExpandParameter(node.id);
                expandBtn.title = 'Try to expand as nested code';
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'action-btn';
                removeBtn.innerHTML = '−';
                removeBtn.title = 'Remove this value';
                removeBtn.onclick = (e) => window.removeParameter(node.id, e);
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'action-btn';
                copyBtn.innerHTML = '📋';
                copyBtn.title = 'Copy this value';
                copyBtn.onclick = () => window.copyParameter(node.id);
                
                valueGroup.appendChild(value);
                valueGroup.appendChild(expandBtn);
                
                // Only add remove button for value nodes that aren't the root
                if (depth > 0) {
                    valueGroup.appendChild(removeBtn);
                }
                
                valueGroup.appendChild(copyBtn);
                
                header.appendChild(expandIcon);
                header.appendChild(valueGroup);
                nodeDiv.appendChild(header);
            }
            
            return nodeDiv;
        }

        function toggleNode(nodeId) {
            const children = document.getElementById(`children-${nodeId}`);
            const icon = document.getElementById(`icon-${nodeId}`);
            
            if (children) {
                const isCurrentlyHidden = children.classList.contains('hidden');
                
                if (isCurrentlyHidden) {
                    children.classList.remove('hidden');
                    icon.textContent = '▼';
                    collapsedNodes.delete(nodeId);
                } else {
                    children.classList.add('hidden');
                    icon.textContent = '▶';
                    collapsedNodes.add(nodeId);
                }
            }
        }

        function updateParameterWithTracking(nodeId, newValue) {
            updateNodeValue(parsedStructure, nodeId, newValue);
            
            const inputElement = document.querySelector(`input[data-id="${nodeId}"]`);
            if (inputElement) {
                const originalValue = inputElement.getAttribute('data-original');
                const expandBtn = inputElement.nextElementSibling;
                if (expandBtn && expandBtn.classList.contains('expand-btn')) {
                    if (newValue !== originalValue) {
                        expandBtn.classList.add('modified');
                    } else {
                        expandBtn.classList.remove('modified');
                    }
                }
            }
        }

        function initializeOriginalValues(node) {
            if (!node.originalValue && node.value) {
                node.originalValue = node.value;
            }
            if (node.parameters) {
                node.parameters.forEach(initializeOriginalValues);
            }
        }

        function updateNodeValue(node, targetId, newValue) {
            if (node.id === targetId) {
                node.value = newValue;
                return true;
            }
            
            if (node.parameters) {
                for (let param of node.parameters) {
                    if (updateNodeValue(param, targetId, newValue)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function exportCode() {
            if (!parsedStructure) {
                showError('Please parse some code first.');
                return;
            }
            
            let newStatement;
            if (codeFormat === 'using') {
                newStatement = `using ${parsedStructure.variableName} = ${buildExpression(parsedStructure)};`;
            } else if (codeFormat === 'styleptr') {
                newStatement = `StylePtr<${buildExpression(parsedStructure)}>()`;
            }
            
            const finalCode = codePrefix + newStatement + codeSuffix;
            
            navigator.clipboard.writeText(finalCode).then(() => {
                const btn = document.querySelector('.export-btn');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = 'linear-gradient(45deg, #27ae60, #2ecc71)';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = 'linear-gradient(45deg, #3498db, #2980b9)';
                }, 2000);
            }).catch(err => {
                showError('Failed to copy to clipboard: ' + err.message);
            });
        }

        function buildExpression(node) {
            if (node.type === 'value') {
                return node.value;
            } else if (node.type === 'function') {
                const params = node.parameters?.map(p => buildExpression(p)).join(',') || '';
                return `${node.name}<${params}>`;
            }
            return '';
        }

        function clearForm() {
            document.getElementById('codeInput').value = '';
            document.getElementById('treeView').innerHTML = '';
            document.getElementById('treeView').classList.add('hidden');
            clearError();
            
            parsedStructure = null;
            originalCode = '';
            codePrefix = '';
            codeSuffix = '';
            codeFormat = '';
            collapsedNodes.clear();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const addModal = document.getElementById('addModal');
            const removeModal = document.getElementById('removeModal');
            if (event.target === addModal) {
                closeAddModal();
            } else if (event.target === removeModal) {
                cancelRemove();
            }
        }

        // Handle Enter key in modal inputs
        document.addEventListener('DOMContentLoaded', function() {
            const inputs = document.querySelectorAll('#addModal input');
            inputs.forEach(input => {
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        confirmAddParameter();
                    }
                });
            });
        });

        window.onload = function() {
            // Ready to go
        };
    </script>
</body>
</html>